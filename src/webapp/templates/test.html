<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>2-comp + depot course (SVG)</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
        .row { display:flex; gap:10px; flex-wrap:wrap; align-items:end; }
        label { display:grid; gap:6px; font-size:13px; }
        input, select { padding:8px 10px; border:1px solid #ddd; border-radius:10px; }
        button { padding:9px 12px; border:0; border-radius:10px; cursor:pointer; }
        #wrap { margin-top: 14px; padding: 12px; border: 1px solid #eee; border-radius: 14px; }
        #chart svg { width: 100%; height: auto; display:block; }
    </style>
</head>
<body>

<div class="row">
    <label>Препарат<select id="drug"></select></label>
    <label>Доза (mg)<input id="dose" value="2.5"></label>
    <label>Курс (weeks)<input id="weeks" value="8"></label>
    <label>Интервал (days)<input id="interval" value="7"></label>


    <button id="run">Run</button>
    <button id="download">Download SVG</button>
</div>

<div id="wrap"><div id="chart"></div></div>

<script>
    const DEFAULT_DT_BASE = 0.1;
    const DEFAULT_DT_DENSE = 0.02;
    const DEFAULT_DENSE_WIN = 2.5;

    document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("dtBase").value = String(DEFAULT_DT_BASE);
        document.getElementById("dtDense").value = String(DEFAULT_DT_DENSE);
        document.getElementById("denseWin").value = String(DEFAULT_DENSE_WIN);
    });

    const PEPTIDE_DATA = {
        semaglutide: { name: "Семаглутид", t_half_days: 7.0, F: 0.89, tmax_h: 48.0 },
        tirzepatide: { name: "Тирзепатид", t_half_days: 5.5, F: 0.80, tmax_h: 36.0 },
        retatrutide: { name: "Ретатрутид", t_half_days: 6.0, F: 0.80, tmax_h: 24.0 },
        cagrilintide: { name: "Кагрилинтид", t_half_days: 8.0, F: 0.80, tmax_h: 48.0 },
        survodutide: { name: "Сурводутид", t_half_days: 6.0, F: 0.80, tmax_h: 30.0 },
        mazdutide: { name: "Маздутид", t_half_days: 8.0, F: 0.80, tmax_h: 72.0 },
    };

    function getParam(obj, key, defVal=null){ return (obj && obj[key] != null) ? obj[key] : defVal; }
    function requirePositiveFloat(obj, ...keys){
        for (const k of keys){
            const v = obj[k];
            if (v != null){
                const f = Number(v);
                if (Number.isFinite(f) && f > 0) return f;
            }
        }
        throw new Error(`Missing required positive float: one of ${keys.join(", ")}`);
    }

    function betaFromMicro(k10, k12, k21){
        const S = k10 + k12 + k21;
        let disc = S*S - 4.0*k10*k21;
        if (disc < 0) disc = 0;
        return 0.5*(S - Math.sqrt(disc));
    }

    function k10FromTerminalHalfLife(tHalfDays, k12, k21){
        if (!(tHalfDays > 0)) throw new Error("t_half_days must be > 0");
        const betaTarget = Math.log(2) / tHalfDays;
        if (k21 <= betaTarget * 1.000001) k21 = betaTarget * 1.5;
        const num = betaTarget*(k12 + k21) - betaTarget*betaTarget;
        const den = (k21 - betaTarget);
        let k10 = num / den;

        if (!Number.isFinite(k10) || k10 <= 0){
            let lo = 1e-6, hi = 100.0;
            for (let i=0;i<80;i++){
                const mid = 0.5*(lo+hi);
                const b = betaFromMicro(mid, k12, k21);
                if (b > betaTarget) hi = mid;
                else lo = mid;
            }
            k10 = 0.5*(lo+hi);
        }
        return k10;
    }

    function rk4Step(Adep, Ac, Ap, dt, ka, k10, k12, k21){
        function deriv(dep,c,p){
            const ddep = -ka*dep;
            const dc = ka*dep - (k10+k12)*c + k21*p;
            const dp = k12*c - k21*p;
            return [ddep, dc, dp];
        }
        const k1 = deriv(Adep,Ac,Ap);
        const k2 = deriv(Adep + 0.5*dt*k1[0], Ac + 0.5*dt*k1[1], Ap + 0.5*dt*k1[2]);
        const k3 = deriv(Adep + 0.5*dt*k2[0], Ac + 0.5*dt*k2[1], Ap + 0.5*dt*k2[2]);
        const k4 = deriv(Adep + dt*k3[0],     Ac + dt*k3[1],     Ap + dt*k3[2]);

        let AdepN = Adep + (dt/6.0)*(k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
        let AcN   = Ac   + (dt/6.0)*(k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
        let ApN   = Ap   + (dt/6.0)*(k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);

        if (AdepN < 0) AdepN = 0;
        if (AcN < 0)   AcN = 0;
        if (ApN < 0)   ApN = 0;
        return [AdepN, AcN, ApN];
    }

    function tPeakForKa(ka, doseToDepot, k10,k12,k21, dt, tEnd){
        let Adep = doseToDepot, Ac = 0, Ap = 0;
        let bestT = 0, bestVal = -1;
        let t = 0;
        while (t <= tEnd + 1e-12){
            const val = Ac + Ap;
            if (val > bestVal){ bestVal = val; bestT = t; }
            [Adep,Ac,Ap] = rk4Step(Adep,Ac,Ap, dt, ka, k10,k12,k21);
            t += dt;
        }
        return bestT;
    }

    function solveKaByTargetTmax(targetTmaxDays, doseToDepot, k10,k12,k21, dt=0.005){
        if (!(targetTmaxDays > 0)) throw new Error("target_tmax_days must be > 0");
        if (!(doseToDepot > 0)) throw new Error("dose_to_depot must be > 0");
        const tEnd = Math.max(10.0, 6.0*targetTmaxDays);

        let lo = 1e-4, hi = 50.0;
        const tLo = tPeakForKa(lo, doseToDepot, k10,k12,k21, dt, tEnd);
        const tHi = tPeakForKa(hi, doseToDepot, k10,k12,k21, dt, tEnd);

        if (tHi > targetTmaxDays) return hi;
        if (tLo < targetTmaxDays) return lo;

        for (let i=0;i<40;i++){
            const mid = 0.5*(lo+hi);
            const tm = tPeakForKa(mid, doseToDepot, k10,k12,k21, dt, tEnd);
            if (tm > targetTmaxDays) lo = mid;
            else hi = mid;
        }
        return 0.5*(lo+hi);
    }

    function nDosesFromCourse(weeks, intervalDays){
        if (!(weeks > 0)) throw new Error("weeks must be > 0");
        if (!(intervalDays > 0)) throw new Error("interval_days must be > 0");
        const totalDays = weeks * 7.0;
        return Math.max(1, Math.ceil(totalDays / intervalDays));
    }

    function simulateCourseAmountOnly(drugKey, doseMg, weeks, intervalDays, dtBase=DEFAULT_DT_BASE, dtDense=DEFAULT_DT_DENSE, denseWindowDays=DEFAULT_DENSE_WIN){
        if (!(doseMg > 0)) throw new Error("dose_mg must be > 0");
        const drug = PEPTIDE_DATA[drugKey];
        if (!drug) throw new Error(`Unknown drug: ${drugKey}`);

        const tHalfDays = requirePositiveFloat(drug, "t_half_days");
        const F = Number(getParam(drug, "F", 1.0));
        if (!(F > 0 && F <= 1)) throw new Error(`Invalid F: ${F}`);

        const tlagH = Number(getParam(drug, "tlag_h", 0.0));
        const tlagDays = Math.max(0, tlagH) / 24.0;

        let k12 = Number(getParam(drug, "k12_per_day", 1.2));
        let k21 = Number(getParam(drug, "k21_per_day", 0.8));
        if (!(k12 > 0)) k12 = 1.2;
        if (!(k21 > 0)) k21 = 0.8;

        const k10 = k10FromTerminalHalfLife(tHalfDays, k12, k21);
        const beta = betaFromMicro(k10, k12, k21);

        const doseToDepot = F * doseMg;
        const tmaxH = getParam(drug, "tmax_h", null);

        let ka;
        if (tmaxH != null && Number(tmaxH) > 0){
            const targetTmaxDays = Number(tmaxH) / 24.0;
            ka = solveKaByTargetTmax(targetTmaxDays, doseToDepot, k10,k12,k21, 0.005);
        } else {
            ka = Math.max(0.3, 3.0*beta);
        }

        const nDoses = nDosesFromCourse(weeks, intervalDays);
        const injTimes = Array.from({length:nDoses}, (_,i)=> i*intervalDays);
        const doseEventTimes = injTimes.map(t => t + tlagDays);
        const tEnd = doseEventTimes[doseEventTimes.length-1] + 5.0*tHalfDays;

        const times = [];
        const amounts = [];

        let Adep=0, Ac=0, Ap=0;
        let eventIdx=0;
        let t=0;

        while (t <= tEnd + 1e-12){
            while (eventIdx < doseEventTimes.length && t >= doseEventTimes[eventIdx] - 1e-12){
                Adep += doseToDepot;
                eventIdx += 1;
            }

            times.push(t);
            amounts.push(Ac + Ap);

            let dt = dtBase;

            if (eventIdx < doseEventTimes.length){
                if (Math.abs(doseEventTimes[eventIdx] - t) < denseWindowDays) dt = Math.min(dt, dtDense);
            }
            if (eventIdx > 0){
                if ((t - doseEventTimes[eventIdx-1]) < denseWindowDays) dt = Math.min(dt, dtDense);
            }

            if (eventIdx < doseEventTimes.length){
                const nextEvent = doseEventTimes[eventIdx];
                if (t < nextEvent && t + dt > nextEvent) dt = Math.max(1e-6, nextEvent - t);
            }

            if (t + dt > tEnd){
                dt = tEnd - t;
                if (dt <= 1e-12) break;
            }

            [Adep,Ac,Ap] = rk4Step(Adep,Ac,Ap, dt, ka, k10,k12,k21);
            t += dt;
        }

        const baseLabel = `${drug.name}: ${doseMg}мг каждые ${intervalDays}д`;
        const info = { F, t_half_days: tHalfDays, ka, weeks, interval_days: intervalDays, dose_mg: doseMg };
        return {times, amounts, baseLabel, info, drugName: drug.name};
    }

    const NS = "http://www.w3.org/2000/svg";
    function svgEl(name, attrs = {}, text=null){
        const n = document.createElementNS(NS, name);
        for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
        if (text != null) n.textContent = text;
        return n;
    }
    function fmt(n, d=2){ return Number.isFinite(n) ? n.toFixed(d) : "NaN"; }

    function plotSeriesSVG(host, x, y, {title, yLabel, info}){
        host.innerHTML = "";

        const W = 1200, H = 600;
        const padL = 80, padR = 24, padT = 56, padB = 64;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        const xMin = x.length ? x[0] : 0;
        const xMax = x.length ? x[x.length-1] : 1;

        let yMax = 0;
        for (const v of y) if (v > yMax) yMax = v;
        const yTop = Math.max(1e-9, 2.0 * yMax);

        const svg = svgEl("svg", { width: W, height: H, viewBox: `0 0 ${W} ${H}` });
        svg.appendChild(svgEl("rect", { x:0, y:0, width:W, height:H, fill:"white" }));

        const defs = svgEl("defs");
        const clipId = "clip_plot_" + Math.random().toString(16).slice(2);
        const clip = svgEl("clipPath", { id: clipId });
        clip.appendChild(svgEl("rect", { x:padL, y:padT, width:plotW, height:plotH }));
        defs.appendChild(clip);
        svg.appendChild(defs);

        const X = (v)=> padL + (v - xMin) * (plotW / (xMax - xMin || 1));
        const Y = (v)=> padT + (1 - (v / yTop)) * plotH;

        const grid = svgEl("g");
        const startTick = Math.floor(xMin / 2) * 2;
        const endTick = Math.ceil(xMax / 2) * 2;

        for (let t = startTick; t <= endTick + 1e-9; t += 2){
            const xx = X(t);
            grid.appendChild(svgEl("line", { x1:xx, y1:padT, x2:xx, y2:padT+plotH, stroke:"#000", "stroke-width":1, opacity:0.08 }));
            grid.appendChild(svgEl("text", { x:xx, y:padT+plotH+26, "font-size":12, fill:"#000", opacity:0.65, "text-anchor":"middle" }, String(t)));
        }

        const ySteps = 5;
        for (let i=0;i<=ySteps;i++){
            const val = (yTop/ySteps)*i;
            const yy = Y(val);
            grid.appendChild(svgEl("line", { x1:padL, y1:yy, x2:padL+plotW, y2:yy, stroke:"#000", "stroke-width":1, opacity:0.08 }));
            grid.appendChild(svgEl("text", { x:padL-10, y:yy+4, "font-size":12, fill:"#000", opacity:0.65, "text-anchor":"end" }, fmt(val, 0)));
        }
        svg.appendChild(grid);

        svg.appendChild(svgEl("line", { x1:padL, y1:padT, x2:padL, y2:padT+plotH, stroke:"#000", "stroke-width":1, opacity:0.25 }));
        svg.appendChild(svgEl("line", { x1:padL, y1:padT+plotH, x2:padL+plotW, y2:padT+plotH, stroke:"#000", "stroke-width":1, opacity:0.25 }));

        let d = "";
        for (let i=0;i<x.length;i++){
            const px = X(x[i]);
            const py = Y(y[i]);
            d += (i===0 ? `M ${px} ${py}` : ` L ${px} ${py}`);
        }

        const baseY = Y(0);
        const dFill = `${d} L ${X(xMax)} ${baseY} L ${X(xMin)} ${baseY} Z`;

        const series = svgEl("g", { "clip-path": `url(#${clipId})` });
        series.appendChild(svgEl("path", { d: dFill, fill:"#000", opacity:0.12 }));
        series.appendChild(svgEl("path", { d, fill:"none", stroke:"#000", "stroke-width":2.2, opacity:0.9 }));
        svg.appendChild(series);

        svg.appendChild(svgEl("text", { x:W/2, y:32, "font-size":16, fill:"#000", "text-anchor":"middle" }, title));
        svg.appendChild(svgEl("text", { x:W/2, y:H-18, "font-size":12, fill:"#000", opacity:0.7, "text-anchor":"middle" }, "Дни от начала"));
        svg.appendChild(svgEl("text", { x:22, y:H/2, "font-size":12, fill:"#000", opacity:0.7, transform:`rotate(-90 22 ${H/2})`, "text-anchor":"middle" }, yLabel));

        if (info){
            const boxW = 270, boxH = 110;
            const boxX = padL + 12, boxY = padT + 12;
            svg.appendChild(svgEl("rect", { x:boxX, y:boxY, width:boxW, height:boxH, rx:12, ry:12, fill:"#fff", stroke:"#000", "stroke-width":1, opacity:0.18 }));
            const lines = [
                `Доза: ${info.dose_mg}мг`,
                `Интервал: ${info.interval_days}д`,
                `Курс: ${info.weeks}нед`,
                `Усвоение: ${fmt(info.F*100,2)}%`,
                `t½: ${fmt(info.t_half_days,2)}д`,
            ];
            lines.forEach((s, idx)=>{
                svg.appendChild(svgEl("text", { x:boxX+12, y:boxY+22+idx*18, "font-size":12, fill:"#000", opacity:0.85 }, s));
            });
        }

        host.appendChild(svg);
        return svg;
    }

    function downloadSvg(svg, filename="drug_amount_plot.svg"){
        const xml = new XMLSerializer().serializeToString(svg);
        const blob = new Blob([xml], { type:"image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = filename;
        document.body.appendChild(a);
        a.click(); a.remove();
        URL.revokeObjectURL(url);
    }

    const chartHost = document.getElementById("chart");
    const selectEl = document.getElementById("drug");
    let lastSvg = null;

    function fillSelect(){
        const keys = Object.keys(PEPTIDE_DATA).sort((a,b)=> (PEPTIDE_DATA[a].name || a).localeCompare(PEPTIDE_DATA[b].name || b, "ru"));
        selectEl.innerHTML = "";
        for (const k of keys){
            const opt = document.createElement("option");
            opt.value = k;
            opt.textContent = PEPTIDE_DATA[k].name;
            selectEl.appendChild(opt);
        }
        selectEl.value = "semaglutide";
    }

    function num(id){
        const v = document.getElementById(id).value.trim().replace(",", ".");
        const n = Number(v);
        if (!Number.isFinite(n)) throw new Error(`Bad number in ${id}`);
        return n;
    }

    function run(){
        const drugKey = selectEl.value;
        const dose = num("dose");
        const weeks = num("weeks");
        const interval = num("interval");

        const {times, amounts, baseLabel, info, drugName} =
            simulateCourseAmountOnly(drugKey, dose, weeks, interval, DEFAULT_DT_BASE, DEFAULT_DT_DENSE, DEFAULT_DENSE_WIN);

        lastSvg = plotSeriesSVG(chartHost, times, amounts, {
            title: `Содержание вещества в организме (мг) — ${drugName}`,
            yLabel: "Содержание, мг",
            legendLabel: baseLabel,
            info
        });
    }

    document.getElementById("run").addEventListener("click", ()=>{ try { run(); } catch (e){ alert(e?.message || String(e)); }});
    document.getElementById("download").addEventListener("click", ()=>{ if (lastSvg) downloadSvg(lastSvg, "drug_amount_plot.svg"); });
    selectEl.addEventListener("change", ()=>{ try { run(); } catch {} });

    fillSelect();
    run();
</script>
</body>
</html>